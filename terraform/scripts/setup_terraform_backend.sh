#!/bin/bash
# Terraform Remote State Backend Setup Script
# This script creates the S3 bucket and DynamoDB table for Terraform state management

set -e

# Configuration
BUCKET_NAME="ds-devops-project-terraform-state"
DYNAMODB_TABLE="ds-devops-terraform-locks"
AWS_REGION="us-east-1"
ENVIRONMENT="prod"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if AWS CLI is installed and configured
check_aws_cli() {
    if ! command -v aws &> /dev/null; then
        print_error "AWS CLI is not installed. Please install it first."
        exit 1
    fi
    
    if ! aws sts get-caller-identity &> /dev/null; then
        print_error "AWS CLI is not configured. Please run 'aws configure' first."
        exit 1
    fi
    
    print_status "AWS CLI is installed and configured"
}

# Function to create S3 bucket for Terraform state
create_s3_bucket() {
    print_status "Creating S3 bucket: $BUCKET_NAME"
    
    # Check if bucket already exists
    if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
        print_warning "S3 bucket '$BUCKET_NAME' already exists"
        return 0
    fi
    
    # Create bucket
    if [ "$AWS_REGION" == "us-east-1" ]; then
        aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$AWS_REGION"
    else
        aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$AWS_REGION" \
            --create-bucket-configuration LocationConstraint="$AWS_REGION"
    fi
    
    # Enable versioning
    aws s3api put-bucket-versioning \
        --bucket "$BUCKET_NAME" \
        --versioning-configuration Status=Enabled
    
    # Enable server-side encryption
    aws s3api put-bucket-encryption \
        --bucket "$BUCKET_NAME" \
        --server-side-encryption-configuration '{
            "Rules": [
                {
                    "ApplyServerSideEncryptionByDefault": {
                        "SSEAlgorithm": "AES256"
                    }
                }
            ]
        }'
    
    # Block public access
    aws s3api put-public-access-block \
        --bucket "$BUCKET_NAME" \
        --public-access-block-configuration \
        BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
    
    # Add lifecycle policy to manage old versions
    aws s3api put-bucket-lifecycle-configuration \
        --bucket "$BUCKET_NAME" \
        --lifecycle-configuration '{
            "Rules": [
                {
                    "ID": "DeleteOldVersions",
                    "Status": "Enabled",
                    "NoncurrentVersionExpiration": {
                        "NoncurrentDays": 90
                    },
                    "Filter": {
                        "Prefix": ""
                    }
                }
            ]
        }'
    
    print_status "S3 bucket '$BUCKET_NAME' created successfully"
}

# Function to create DynamoDB table for state locking
create_dynamodb_table() {
    print_status "Creating DynamoDB table: $DYNAMODB_TABLE"
    
    # Check if table already exists
    if aws dynamodb describe-table --table-name "$DYNAMODB_TABLE" &> /dev/null; then
        print_warning "DynamoDB table '$DYNAMODB_TABLE' already exists"
        return 0
    fi
    
    # Create table
    aws dynamodb create-table \
        --table-name "$DYNAMODB_TABLE" \
        --attribute-definitions AttributeName=LockID,AttributeType=S \
        --key-schema AttributeName=LockID,KeyType=HASH \
        --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
        --region "$AWS_REGION"
    
    # Wait for table to be active
    print_status "Waiting for DynamoDB table to be active..."
    aws dynamodb wait table-exists --table-name "$DYNAMODB_TABLE" --region "$AWS_REGION"
    
    # Enable point-in-time recovery
    aws dynamodb update-continuous-backups \
        --table-name "$DYNAMODB_TABLE" \
        --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true \
        --region "$AWS_REGION"
    
    print_status "DynamoDB table '$DYNAMODB_TABLE' created successfully"
}

# Function to create backend configuration file
create_backend_config() {
    print_status "Creating Terraform backend configuration"
    
    cat > "../backend.tf" << EOF
# Terraform Backend Configuration
# This file is auto-generated by setup_terraform_backend.sh
terraform {
  backend "s3" {
    bucket         = "$BUCKET_NAME"
    key            = "terraform.tfstate"
    region         = "$AWS_REGION"
    dynamodb_table = "$DYNAMODB_TABLE"
    encrypt        = true
  }
}
EOF
    
    print_status "Backend configuration file created at terraform/backend.tf"
}

# Function to update main.tf to remove commented backend
update_main_tf() {
    print_status "Updating main.tf to use separate backend configuration"
    
    # Comment out the backend section in main.tf
    sed -i 's/^# terraform {/# Backend configuration moved to backend.tf\n# terraform {/' ../main.tf
    
    print_status "main.tf updated"
}

# Function to create environment-specific backend configs
create_env_backend_configs() {
    print_status "Creating environment-specific backend configurations"
    
    for env in dev staging prod; do
        cat > "../backend-${env}.tf" << EOF
# Terraform Backend Configuration for $env environment
terraform {
  backend "s3" {
    bucket         = "$BUCKET_NAME"
    key            = "$env/terraform.tfstate"
    region         = "$AWS_REGION"
    dynamodb_table = "$DYNAMODB_TABLE"
    encrypt        = true
  }
}
EOF
        print_status "Backend configuration for $env created"
    done
}

# Function to test backend setup
test_backend_setup() {
    print_status "Testing backend setup"
    
    # Test S3 bucket access
    if aws s3 ls s3://"$BUCKET_NAME" &> /dev/null; then
        print_status "S3 bucket access: OK"
    else
        print_error "S3 bucket access: FAILED"
        exit 1
    fi
    
    # Test DynamoDB table access
    if aws dynamodb describe-table --table-name "$DYNAMODB_TABLE" &> /dev/null; then
        print_status "DynamoDB table access: OK"
    else
        print_error "DynamoDB table access: FAILED"
        exit 1
    fi
    
    print_status "Backend setup test completed successfully"
}

# Function to display next steps
show_next_steps() {
    print_status "Backend setup completed successfully!"
    echo ""
    echo "Next steps:"
    echo "1. cd to the terraform directory"
    echo "2. Run 'terraform init' to initialize the backend"
    echo "3. Run 'terraform plan' to see the execution plan"
    echo "4. Run 'terraform apply' to create the infrastructure"
    echo ""
    echo "Environment-specific commands:"
    echo "- Dev: terraform init -backend-config=backend-dev.tf"
    echo "- Staging: terraform init -backend-config=backend-staging.tf"
    echo "- Prod: terraform init -backend-config=backend-prod.tf"
    echo ""
    echo "Backend details:"
    echo "- S3 Bucket: $BUCKET_NAME"
    echo "- DynamoDB Table: $DYNAMODB_TABLE"
    echo "- Region: $AWS_REGION"
}

# Main execution
main() {
    print_status "Starting Terraform backend setup..."
    
    check_aws_cli
    create_s3_bucket
    create_dynamodb_table
    create_backend_config
    create_env_backend_configs
    test_backend_setup
    show_next_steps
    
    print_status "Terraform backend setup completed!"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --bucket)
            BUCKET_NAME="$2"
            shift 2
            ;;
        --table)
            DYNAMODB_TABLE="$2"
            shift 2
            ;;
        --region)
            AWS_REGION="$2"
            shift 2
            ;;
        --help)
            echo "Usage: $0 [OPTIONS]"
            echo "Options:"
            echo "  --bucket BUCKET_NAME    S3 bucket name (default: ds-devops-project-terraform-state)"
            echo "  --table TABLE_NAME      DynamoDB table name (default: ds-devops-terraform-locks)"
            echo "  --region REGION         AWS region (default: us-east-1)"
            echo "  --help                  Show this help message"
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Run main function
main